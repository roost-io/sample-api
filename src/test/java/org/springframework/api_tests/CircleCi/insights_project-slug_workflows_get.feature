# ********RoostGPT********

# Test generated by RoostGPT for test karateCircleCIFile using AI Type Claude AI and AI Model claude-3-7-sonnet-20250219
# 
# Feature file generated for /insights/{project-slug}/workflows_get for http method type GET 
# RoostTestHash=56d2122d35
# 
# 

# ********RoostGPT********
Feature: Get summary metrics for a project's workflows

  Background:
    * def urlBase = karate.properties['URL_BASE']
    * def authToken = karate.properties['AUTH_TOKEN']
    * configure headers = { 'Authorization': 'Basic ' + authToken }

  Scenario Outline: Get workflow metrics with different reporting windows
    Given url urlBase
    And path 'insights', '<project-slug>', 'workflows'
    And param reporting-window = '<reporting-window>'
    When method GET
    Then status 200
    And match response == { items: '#array', next_page_token: '##string' }
    And match each response.items[*] contains { name: '#string', metrics: '#object', window_start: '#string', window_end: '#string', project_id: '#present' }
    And match each response.items[*].metrics contains
      """
      { 
        total_runs: '#number', 
        successful_runs: '#number', 
        mttr: '##number', 
        total_credits_used: '##number', 
        failed_runs: '#number', 
        success_rate: '#number', 
        duration_metrics: '#object', 
        total_recoveries: '##number', 
        throughput: '#number' 
      }
      """
    And match each response.items[*].metrics.duration_metrics contains
      """
      { 
        min: '##number', 
        mean: '##number', 
        median: '##number', 
        p95: '##number', 
        max: '##number', 
        standard_deviation: '##number' 
      }
      """

    Examples:
      | read('insights_project-slug_workflows_get.csv') |

  Scenario: Get workflow metrics with pagination
    Given url urlBase
    And path 'insights', 'gh/CircleCI-Public/api-preview-docs', 'workflows'
    When method GET
    Then status 200
    And match response == { items: '#array', next_page_token: '##string' }
    * def nextPageToken = response.next_page_token
    * if (nextPageToken) karate.call('classpath:features/workflow-metrics-pagination.feature', { nextPageToken: nextPageToken })

  Scenario: Get workflow metrics for a specific branch
    Given url urlBase
    And path 'insights', 'gh/CircleCI-Public/api-preview-docs', 'workflows'
    And param branch = 'main'
    When method GET
    Then status 200
    And match response == { items: '#array', next_page_token: '##string' }
    And match each response.items[*] contains { name: '#string', metrics: '#object', window_start: '#string', window_end: '#string', project_id: '#present' }

  Scenario: Get workflow metrics for all branches
    Given url urlBase
    And path 'insights', 'gh/CircleCI-Public/api-preview-docs', 'workflows'
    And param all-branches = true
    When method GET
    Then status 200
    And match response == { items: '#array', next_page_token: '##string' }
    And match each response.items[*] contains { name: '#string', metrics: '#object', window_start: '#string', window_end: '#string', project_id: '#present' }

  Scenario: Invalid project slug should return an error
    Given url urlBase
    And path 'insights', 'invalid-project-slug', 'workflows'
    When method GET
    Then status 400
    And match response contains { message: '#string' }

  Scenario: Verify workflow metrics data types and constraints
    Given url urlBase
    And path 'insights', 'gh/CircleCI-Public/api-preview-docs', 'workflows'
    When method GET
    Then status 200
    And match each response.items[*].metrics.total_runs >= 0
    And match each response.items[*].metrics.successful_runs >= 0
    And match each response.items[*].metrics.failed_runs >= 0
    And match each response.items[*].window_start matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/
    And match each response.items[*].window_end matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/
    * def verifyDurationMetrics = function(metrics) { return metrics == null || metrics >= 0 }
    And match each response.items[*].metrics.duration_metrics.min == '#? verifyDurationMetrics(_)'
    And match each response.items[*].metrics.duration_metrics.mean == '#? verifyDurationMetrics(_)'
    And match each response.items[*].metrics.duration_metrics.median == '#? verifyDurationMetrics(_)'
    And match each response.items[*].metrics.duration_metrics.p95 == '#? verifyDurationMetrics(_)'
    And match each response.items[*].metrics.duration_metrics.max == '#? verifyDurationMetrics(_)'
